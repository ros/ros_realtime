/*****************************************************************************
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \author Mrinal Kalakrishnan <mail@mrinal.net>
 ******************************************************************************/

#ifndef ROSRT_CONDITION_VARIABLE_H_
#define ROSRT_CONDITION_VARIABLE_H_

#include <boost/utility.hpp>
#include <boost/assert.hpp>
#include <boost/thread/exceptions.hpp>
#include <boost/thread/locks.hpp>
#include <rosrt/detail/mutex.h>

#ifdef __XENO__
#include <native/cond.h>
#else
#include <boost/thread/condition_variable.hpp>
#endif

namespace rosrt
{

/**
 * Wrapper for a "real-time" condition variable, implementation differs based on platform.
 * Falls back to boost::condition_variable on generic platforms.
 *
 * Attempts to mimic the boost::condition_variable api, but this is not a complete implementation,
 * it's only intended for internal rosrt use.
 */
class condition_variable: boost::noncopyable
{
private:

#ifdef __XENO__
  RT_COND cond_;
#else
  boost::condition_variable cond_;
#endif

public:
  condition_variable()
  {
#ifdef __XENO__
    int const res = rt_cond_create(&cond_, NULL);
    if (res)
    {
      throw boost::thread_resource_error();
    }
#endif
  }

  ~condition_variable()
  {
#ifdef __XENO__
    BOOST_VERIFY(!rt_cond_delete(&cond_));
#endif
  }

  void wait(boost::unique_lock<mutex>& m)
  {
#ifdef __XENO__
    rosrt::mutex::native_handle_type native_mutex = m.mutex()->native_handle();
    int const res = rt_cond_wait(&cond_, native_mutex, TM_INFINITE);
    BOOST_VERIFY(!res);
#else
    pthread_cond_t* native_cond = cond_.native_handle();
    pthread_mutex_t* native_mutex = m.mutex()->native_handle();
    BOOST_VERIFY(!pthread_cond_wait(native_cond, native_mutex));
#endif
  }

  template<typename predicate_type>
  void wait(boost::unique_lock<mutex>& m, predicate_type pred)
  {
    while (!pred())
      wait(m);
  }

#ifdef __XENO__
  typedef RT_COND* native_handle_type;
#else
  typedef boost::condition_variable::native_handle_type native_handle_type;
#endif

  native_handle_type native_handle()
  {
#ifdef __XENO__
    return &cond_;
#else
    return cond_.native_handle();
#endif
  }

  void notify_one()
  {
#ifdef __XENO__
    int const res = rt_cond_signal(&cond_);
    if (res)
    {
      ROS_ERROR("rt_cond_signal returned %d", res);
    }
    BOOST_VERIFY(!res);
#else
    cond_.notify_one();
#endif
  }

  void notify_all()
  {
#ifdef __XENO__
    BOOST_VERIFY(!rt_cond_broadcast(&cond_));
#else
    cond_.notify_all();
#endif
  }

};

}

#endif /* ROSRT_CONDITION_VARIABLE_H_ */
